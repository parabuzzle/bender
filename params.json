{"name":"Bender","tagline":"Bender is the IRC bot container that runs on Spunk","body":"[![Stories in Ready](https://badge.waffle.io/parabuzzle/bender.png?label=ready&title=Ready)](https://waffle.io/parabuzzle/bender)\r\n\r\n\r\n#Install\r\n\r\n**Grab Application**\r\n```\r\n$ git clone git://github.com/parabuzzle/bender.git\r\n```\r\n\r\n**Install Gems**\r\n```\r\n$ bundle install\r\n```\r\n\r\n**Run It**\r\n```\r\n$ cd bender\r\n$ ruby bin/server.rb\r\n```\r\n\r\n*note: you can also use foreman to run it: `foreman start`*\r\n\r\n\r\n##Configuration\r\nLook at `config/application.rb` for a list of configuration options and overrides\r\n\r\n*note: Bender is 100% Heroku compatible and configurable via the ENV - https://github.com/parabuzzle/bender/wiki/Using-Bender-on-Heroku*\r\n\r\n\r\n#Extending Bender\r\n*Let's face it... this is what you're interested in ;)*\r\n\r\nThe full (up-to-date) api docs can be found here: http://www.rubydoc.info/github/parabuzzle/bender\r\n\r\n###Directory Structure\r\n```\r\n./config/       # config and initialization\r\n./lib/          # directory with all support libraries (classes/modules)\r\n./processors/   # directory for irc command processors\r\n./servlets/     # directory for servlets\r\n```\r\n\r\n###Autoloader\r\nWhen Bender starts, it auto loads everything so that you just put your extensions in the proper folders with the proper namespacing and restart the application for it to start working. NO EXTRA CONFIG!\r\n\r\n**Load Order**\r\n\r\n  1. Require ./config/application.rb\r\n  1. Require all files in ./config/*.rb\r\n  1. Require all files in ./lib/*.rb\r\n  1. Require all files in ./servlets/*.rb\r\n  1. Require all files in ./processors/*.rb\r\n  1. Start processors - ./processors/*_processor.rb\r\n  1. Start servlets - ./servlets/*_servlet.rb\r\n\r\n**Autoload of Processors**\r\n\r\nThis is done via the `Bender::Processor` namespace. As long as your processor's class is namespaced there, it will be loaded.\r\n\r\nexample:\r\n\r\n```ruby\r\nBender::Processor::BasicProcessor #=> loaded\r\nBender::Processor::AwesomeSauce   #=> loaded\r\nBender::WizBangProcessor          #=> not loaded\r\n```\r\n\r\n**Autoload of Servlets**\r\n\r\nThis is done via the `Bender::HTTP` namespace. As long as your servlet's class is namespaced there, it will be loaded.\r\n\r\nexample:\r\n\r\n```ruby\r\nBender::HTTP::PingServlet  #=> loaded\r\nBender::HTTP::Github       #=> loaded\r\nBender::MyServlet          #=> not loaded\r\n```\r\n\r\n**More info about creating processors and servlets in the next section**\r\n\r\n\r\n### Building an irc command processor\r\nJust subclass `Bender::BaseProcessor` and implement the `#process` method\r\n\r\n**This is what a processor looks like:**\r\n\r\n```ruby\r\nmodule Bender::Processor\r\n  class BasicProcessor < Bender::BaseProcessor\r\n\r\n    # REQUIRED! You must implement the #process method when subclassing the BaseProcessor class\r\n    def process\r\n\r\n      #monitor for the word 'sweet' and respond with 'dude'\r\n      hear(/sweet/i) { reply 'Dude!' }\r\n\r\n      # monitor for my nickname with or without a question mark and respond\r\n      #   ie: `bender?` responds with 'Kiss my shiny metal ass'\r\n      hear(/^#{@bot.nickname}\\??$/) { reply 'Kiss my shiny metal ass' }\r\n\r\n      # respond wraps the previous bot.nickname catching and matches on everything after the nickname\r\n      #   ie: `bender PING` will respond with 'PONG'\r\n      respond(/PING$/) { reply \"PONG\" }\r\n    end\r\n\r\n    # The #help class method is optional but it makes running `bender help` a lot more useful ;)\r\n    # This method should return an array of lines to be printed in the irc\r\n    def self.help\r\n      [\r\n        \"sweet - replies with 'dude'\",\r\n        \"#{Bender.nickname} PING - replies with 'PONG'\",\r\n        \"#{Bender.nickname}? - replies with 'Kiss my shiny metal ass\"\r\n      ]\r\n    end\r\n  end\r\nend\r\n```\r\nYou simply put this code in the `./processors/` directory and restart Bender for this to start working.\r\n\r\n\r\n### Building a servlet\r\nSince Bender uses webrick, creating a servlet for Bender is almost the same as creating an Abstract Servlet in Webrick. **ALMOST**... The only difference is that Bender will provide the Spunk Bot object so that you can access the Spunk IRC bot from within the request to post messages to IRC or display IRC data to a webpage. This is done by inheriting from the `Bender::BaseServlet` class which has the bot.\r\n\r\n**This is what servlet looks like**\r\n\r\n```ruby\r\nclass GitServlet < Bender::BaseServlet\r\n  # Provides a simple bridge of github url post hook data to IRC\r\n  # http://localhost:9091/gitirc?room=github\r\n\r\n  # REQUIRED! so Bender knows where to mount this\r\n  def self.mountpoint\r\n    \"/gitirc\"\r\n  end\r\n\r\n  def do_GET(request, response)\r\n    status = 200\r\n    content_type = \"text/html\"\r\n    body = \"bender version #{BENDER_VERSION}\"\r\n    body += \"\\n\"\r\n\r\n    response.status = status\r\n    response['Content-Type'] = content_type\r\n    response.body = body\r\n    response.body = body\r\n  end\r\n\r\n  def do_POST(request, response)\r\n    status, content_type, body = post_to_irc(request)\r\n\r\n    response.status = status\r\n    response['Content-Type'] = content_type\r\n    response.body = body\r\n  end\r\n\r\n  private\r\n\r\n  def post_to_irc(request)\r\n    bot_hash = {:rooms=>[], :payload=>nil}\r\n    request.query.collect do |key,value|\r\n      if key.match(/^room/)\r\n        bot_hash[:rooms] << '#' + value\r\n      end\r\n      if key.match(/^payload/)\r\n        bot_hash[:payload] = value\r\n      end\r\n    end\r\n    rooms = bot_hash[:rooms]\r\n    rooms.uniq!\r\n\r\n    if bot_hash[:payload]\r\n      j = JSON.parse(bot_hash[:payload])\r\n      repo = j['repository']['name']\r\n      compare = j['compare']\r\n      pusher = j['pusher']['name']\r\n      owner = j['repository']['owner']['name']\r\n      branch = j['ref']\r\n      unless pusher == \"name\"\r\n        rooms.each do |r|\r\n          unless $bot.joined_rooms.include? r\r\n            @bot.join_room r\r\n          end\r\n          @bot.say r, \"[git-push] #{pusher} pushed to #{owner}/#{repo} [ref: #{branch}]\"\r\n          @bot.say r, \"[git-push] #{compare}\"\r\n        end\r\n      end\r\n    end\r\n\r\n    return 200, \"text/plain\", \"accepted\"\r\n  end\r\nend\r\n```\r\n\r\nThis servlet will listen for a post from your github post hook on your repo and bridge the data into the room provided. *ie - http://myserver.com:9019/gitirc?room=github will post to the #github room whenever you push to your repo*\r\n\r\nThis code should be put into the `./servlets/` directory to get included at startup.\r\n\r\n\r\n#Contributing\r\n\r\n  1. fork the repository\r\n  1. create a feature branch\r\n  1. add your awesome code\r\n  1. send a pull request\r\n  1. have a beer\r\n\r\n\r\n#License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013-2015 Michael Heijmans\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}